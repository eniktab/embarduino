#include <driver/ledc.h>
#include <esp_timer.h>
#include "kevin_v1.h"   // generated by: xxd -i output.raw > audio_data.h
#include "kevin_v2.h"   // second audio file

// PWM Configuration
#define PWM_GPIO_PIN      4    // Choose your GPIO pin
#define PWM_CHANNEL       LEDC_CHANNEL_0
#define PWM_TIMER         LEDC_TIMER_0
#define PWM_FREQUENCY     78125          // 78.125 kHz PWM frequency
#define PWM_RESOLUTION    LEDC_TIMER_10_BIT  // 10-bit resolution (0-1023)

// Audio Configuration
static const uint32_t SAMPLE_RATE = 8000;   // Match your PCM data
static const uint32_t SAMPLE_PERIOD_US = 1000000 / SAMPLE_RATE;  // 125 microseconds

// Playback state
static volatile size_t current_sample = 0;
static volatile bool playing = false;
static volatile bool use_v1 = true;  // Flag to alternate between audio files
static esp_timer_handle_t audio_timer;

// Helper function to get current audio data
static const unsigned char* get_current_audio_data() {
    return use_v1 ? kevin_v1_raw : kevin_v2_raw;
}

// Helper function to get current audio data length
static size_t get_current_audio_length() {
    return use_v1 ? kevin_v1_raw_len : kevin_v2_raw_len;
}

// Timer callback function to output next sample
static void IRAM_ATTR audio_timer_callback(void* arg) {
    if (!playing || current_sample >= get_current_audio_length()) {
        playing = false;
        return;
    }

    // Get current audio data
    const unsigned char* audio_data = get_current_audio_data();

    // Get current 8-bit sample (0-255) and convert to PWM duty (0-1023)
    uint8_t sample = audio_data[current_sample];

    // Digital amplification (adjust GAIN_MULTIPLIER to control volume)
    #define GAIN_MULTIPLIER 10  // Increase this for more volume (1.0 = normal, 2.0 = double)

    // Convert to signed, apply gain, then back to PWM range
    int16_t signed_sample = (int16_t)sample - 128;  // Convert to signed (-128 to +127)
    signed_sample = (int16_t)(signed_sample * GAIN_MULTIPLIER);  // Apply gain

    // Clip to prevent distortion
    if (signed_sample > 127) signed_sample = 127;
    if (signed_sample < -128) signed_sample = -128;

    // Convert back to unsigned and scale to PWM
    uint8_t amplified_sample = (uint8_t)(signed_sample + 128);
    uint32_t duty = (amplified_sample * 1023) / 255;

    // Set PWM duty cycle
    ledc_set_duty(LEDC_LOW_SPEED_MODE, PWM_CHANNEL, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, PWM_CHANNEL);

    current_sample++;
}

void setup() {
    Serial.begin(115200);
    delay(100);

    Serial.println("ESP32-S3 Audio PWM Setup");
    Serial.printf("Kevin V1 audio size: %u bytes\n", kevin_v1_raw_len);
    Serial.printf("Kevin V2 audio size: %u bytes\n", kevin_v2_raw_len);
    Serial.printf("Sample rate: %u Hz\n", SAMPLE_RATE);
    Serial.printf("PWM output pin: GPIO%d\n", PWM_GPIO_PIN);
    Serial.println("Connect RC low-pass filter: GPIO -> 1kΩ -> Audio Out");
    Serial.println("                              ↓");
    Serial.println("                           10µF -> GND");
    Serial.println("Will alternate between kevin_v1 and kevin_v2 audio files");

    // Configure PWM (LEDC) for audio output
    ledc_timer_config_t timer_conf = {
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .duty_resolution = PWM_RESOLUTION,
        .timer_num = PWM_TIMER,
        .freq_hz = PWM_FREQUENCY,
        .clk_cfg = LEDC_AUTO_CLK
    };
    ESP_ERROR_CHECK(ledc_timer_config(&timer_conf));

    ledc_channel_config_t channel_conf = {
        .gpio_num = PWM_GPIO_PIN,
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .channel = PWM_CHANNEL,
        .timer_sel = PWM_TIMER,
        .duty = 0,
        .hpoint = 0
    };
    ESP_ERROR_CHECK(ledc_channel_config(&channel_conf));

    // Create high-resolution timer for sample playback
    esp_timer_create_args_t timer_args = {
        .callback = &audio_timer_callback,
        .arg = NULL,
        .dispatch_method = ESP_TIMER_TASK,
        .name = "audio_timer"
    };
    ESP_ERROR_CHECK(esp_timer_create(&timer_args, &audio_timer));

    Serial.println("Setup complete. Ready to play audio.");
}

void loop() {
    if (!playing) {
        // Display which audio file is about to play
        Serial.printf("Starting playback of %s (%u bytes)...\n",
                     use_v1 ? "kevin_v1" : "kevin_v2",
                     get_current_audio_length());

        // Reset playback position
        current_sample = 0;
        playing = true;

        // Start the timer
        ESP_ERROR_CHECK(esp_timer_start_periodic(audio_timer, SAMPLE_PERIOD_US));

        // Wait for playback to complete
        while (playing) {
            delay(100);
        }

        // Stop the timer
        esp_timer_stop(audio_timer);

        // Set PWM to middle value (silence)
        ledc_set_duty(LEDC_LOW_SPEED_MODE, PWM_CHANNEL, 512);
        ledc_update_duty(LEDC_LOW_SPEED_MODE, PWM_CHANNEL);

        Serial.printf("Playback complete. Played %u samples from %s\n",
                     current_sample, use_v1 ? "kevin_v1" : "kevin_v2");

        // Switch to the other audio file for next playback
        use_v1 = !use_v1;
        Serial.printf("Next playback will be: %s\n", use_v1 ? "kevin_v1" : "kevin_v2");

        delay(2000);  // Wait before next playback
    }
}

// Alternative I2S PDM implementation (comment out PWM code above to use this)
/*
#include <driver/i2s.h>

static const i2s_port_t I2S_PORT = I2S_NUM_0;
static const uint32_t SAMPLE_RATE = 8000;
#define I2S_PDM_GPIO_CLK  GPIO_NUM_17
#define I2S_PDM_GPIO_DOUT GPIO_NUM_18

void setup() {
    Serial.begin(115200);
    delay(100);

    // Configure I2S for PDM output
    i2s_config_t i2s_cfg = {
        .mode = i2s_mode_t(I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_PDM),
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = 4,
        .dma_buf_len = 64,
        .use_apll = false,
        .tx_desc_auto_clear = true
    };

    i2s_pin_config_t pin_cfg = {
        .bck_io_num = I2S_PIN_NO_CHANGE,
        .ws_io_num = I2S_PIN_NO_CHANGE,
        .data_out_num = I2S_PDM_GPIO_DOUT,
        .data_in_num = I2S_PIN_NO_CHANGE
    };

    ESP_ERROR_CHECK(i2s_driver_install(I2S_PORT, &i2s_cfg, 0, NULL));
    ESP_ERROR_CHECK(i2s_set_pin(I2S_PORT, &pin_cfg));

    Serial.println("I2S PDM Setup complete");
}

void loop() {
    size_t bytes_written = 0;

    // Convert 8-bit samples to 16-bit for I2S
    size_t current_len = use_v1 ? kevin_v1_raw_len : kevin_v2_raw_len;
    const unsigned char* current_data = use_v1 ? kevin_v1_raw : kevin_v2_raw;

    int16_t* samples_16bit = (int16_t*)malloc(current_len * 2);
    for (size_t i = 0; i < current_len; i++) {
        samples_16bit[i] = (int16_t)((current_data[i] - 128) * 256);  // Convert unsigned 8-bit to signed 16-bit
    }

    i2s_write(I2S_PORT, samples_16bit, current_len * 2, &bytes_written, portMAX_DELAY);

    free(samples_16bit);
    Serial.printf("Played %u bytes from %s\n", bytes_written, use_v1 ? "kevin_v1" : "kevin_v2");

    // Switch to the other audio file for next playback
    use_v1 = !use_v1;
    delay(500);
}
*/